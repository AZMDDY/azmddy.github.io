# 基数排序

> 基数排序是一种非比较型的整数排序算法，其原理是将整数按位分割成不同的数字，然后按照每个位数分别比较。由于整数也可以表达字符串和特定格式的浮点数，所以基数排序也不是只能用于整数。

基数排序的时间复杂度是$O(k·n)$，其中$n$是排序元素个数，$k$是数字位数。注意这不是说这个时间复杂度一定优于$O(n·log(n))$，$k$的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小，$k$决定了进行多少轮处理，而$n$是每轮处理的操作数目。

简单实现：

```cpp
// 从小到大排序(正数，负数均可排序)
template<class T>
void RadixSort(std::vector<T>& arr)
{
    // 求出待排序数组中的最大值，用于确定最大位数
    T maxVal = *(std::max_element(arr.begin(), arr.end()));
    std::vector<T> tmp = arr;
    // 存放待排序数组中元素的某个位数的次数，考虑了负数
    std::array<int, 20> count{};
    for (int64_t exp = 1; maxVal / exp > 0; exp *= 10) {
        count.fill(0);
        // 统计某个位的数出现的次数
        for (int i = 0; i < arr.size(); i++) {
            count[10 + (arr[i] / exp) % 10]++;
        }
        // 以下累计操作是为了计算按某个位数排序后，最右边的那个位数（一次统计下来，可能存在位数相同的情况）的位置
        // 以正数为例:
        //某的位上的值:  1 1 1 2 2 3 3 3 3 4
        //              1 2 3 4 5 6 7 8 9 10
        // count[1] = 3 表示位数是1的最右边的那个数所在位置
        for (int i = 9; i > 0; i--) {
            count[i - 1] += count[i];
        }
        // 正数的情况
        count[10] += count[0];
        for (int i = 11; i < 20; i++) {
            count[i] += count[i - 1];
        }
        // 按照位序填充数组
        for (int i = arr.size() - 1; i >= 0; i--) {
            tmp[count[10 + (arr[i] / exp) % 10] - 1] = arr[i];
            count[10 + (arr[i] / exp) % 10]--;
        }
        arr = tmp;
    }
}
```