# bind 函数

使用 bind 函数需要包含 functional 头文件，并且 bind 函数位于命名空间 std 中，它的作用正如它的名字那样，**捆绑，结合**，对它的使用可以理解为类似于控制变量法。例如：$y_1 = f(x_1,x_2,x_3)$,当$x_1$为一个常量的时候，它就变成了$y_1^1=f(c, x_2, x_3)$,而 bind 函数的作用和这个类似，但更进一步，它会将返回一个函数对象，比如将$y_1->y_1^1的过程变成了y_1->y_2的过程，而y_2=f(x_2,x_3)$。

在使用 bind 函数时，通过绑定参数，返回一个新的函数。

```cpp

int add(int a, intb){
    return a + b;
}

auto add1 = std::bind(add, 2, 3);

std::cout << add1(); // 5
// same as:
// std::cout << add(2, 3);

```

上面的例子展现了利用 bind 函数绑定一个函数的全部参数，如果需要绑定部分参数，则需要是使用到占位符 **placeholders**,占位符的表示： `_n`,`_n`都定义在 placeholders 的命名空间中，而这个命名空间本身定义在 std 名称空间中，所以，这两个命名空间都需要使用。

占位符的作用是在返回的函数对象中参数对原来函数参数的映射。

```cpp
using namespace std::placeholders;
// 现有一个含有四个参数的f函数
f(a, b, c, d);

// c1, c2为定值
// 通过绑定，c1->a, _2->b, c2->c, _1->d;
auto g = std::bind(f,c1, _2, c2, _1);

// 此时g函数: g(_1, _2);
// bind函数将g(_1, _2)映射为f(a, _2, c, _1);

g(X, Y);
// same as:
// f(c1, Y, c2, X);
```

通过上面的例子，可以发现我们可以通过 bind 函数改变参数的顺序。

在默认情况下， bind 的那些不是占位符的参数是被拷贝到 bind 返回的函数对象的，但是呢,有时候绑定的参数类型无法拷贝，或者我们希望以引用方式传递。这时候我们必须使用 ref 函数。
