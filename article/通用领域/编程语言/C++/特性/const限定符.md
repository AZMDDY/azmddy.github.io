---
sort: 1
---



# const限定符

>  **const**限定符，限定变量的值不能被改变，更准确的说是不能通过这个变量去改变这个变量的值，因为有指针和引用这两个东西。

## const & define & enum

这三者都能够定义常量：

+ const:
  + 有类型检查
  + 不会改变变量的作用域
+ define:
  + 没有类型安全检查
  + 直接替换字符串
  + 作用域从定义到*文件尾*，这里的*文件尾*是预编译处理时的文件展开的文件尾，除非使用**#undef**
+ enum:
  + 有类型检查
  + 只能是整型
  + 定义一类相关的常量，enum变量的值只能是这一类常量，安全性更高

## const & 指针

有时候很容易搞混淆，指针常量，常量指针（指向常量的指针）傻傻分不清。关键点在于要搞清楚**const**修饰的是谁。

```cpp
int* a = nullptr;
const int* a = nullptr;
int* const a = nullptr;
const int* const a = nullptr;
```

对于`const int* a = nullptr;`，首先看**const**修饰的是`int* a`, 大家都知道`a`是指针，`*a`是`a`指针指向的值。那么`const int* a = nullptr;`就表示`a`指针指向的值不能通过`*a`去改变，不严谨的说，也就是`a`是指向常量的指针。`a`不一定要指向一个常量，编译器也不会去检查`a`是否真的指向的是一个常量，`a`也可以指向一个变量，只是不能通过`*a`去改变值而已。

对于`int* const a = nullptr;`，还是同样的思路，**const**修饰的是`a`，也就是说`a`的值不能改变，即`a`是指针常量；

那对于const修饰的函数入参和返回值都是如此。

## const & 引用

这里要说的不是`const修饰引用表示不能通过这个引用去改变它的值`，而是可以用右值来初始化**const左值引用**，即`const int& a = 5`。`5`是一个`亡值`，不能取地址，也就无法引用它，但**const**修饰后，可以在数据段开辟一个值为`5`的无名整型量，然后`a`与这个整型量进行绑定。

## const & 类

类中定义的常量只能通过初始化列表的形式进行初始化或者`声明立即初始化`，当然，使用了`static`就可以在类外进行初始化了。

## const & 函数

1. const不能修饰非成员函数。
2. const修饰的成员函数不能访问非const成员。
3. const是作为函数签名的一部分。

`const`修饰的函数中不能访问非`const`变量。也就是说`void Func();`和`void Func() const;`是两个不同的函数。

