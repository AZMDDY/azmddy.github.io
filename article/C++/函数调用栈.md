# 函数调用栈

> 随着学习工作的深入，C++的底层实现和逻辑愈发的关键和重要，很多知识不再是停留在“书上是这么说的，实际上也是这样的”来解释，我们可以用最本质的答案来解释那些知识。



## 打印运行栈



## 汇编指令

> gdb反汇编的结果默认是`AT&T`风格的汇编语言。

`AT&T`风格简单介绍：

+ 立即数：`$`开头；例如：`$0x28`
+ 寄存器：`%`开头；例如：`%rbp`
+ 源操作数在前，目的操作数在后（从前往后读）
+ 操作位数：指令+b(byte),w(word),l(long),q(quad word)



约定：

`I`：立即数，常数

`S`：源操作数（立即数，内存，寄存器）

`D`：目的操作数（立即数，内存，寄存器）

`R`：寄存器



```assembly
; rsp是堆栈指针寄存器(stack pointer)，指向栈顶位置。 ———— 栈顶指针
; rbp是栈帧指针寄存器(frame pointer), 标识当前栈帧的起始位置。———— 栈基指针
```



```assembly
; 栈帧指令

push S ; 压入调用栈
pop S  ; 弹出调用栈
```



```assembly
; 操作地址

lea S, D ; D = &S
```



```assembly
; 转移指令

call ptr

ret
```





```assembly
; 数据传送

; mov
mov %rsp,%rbp ; rbp = rsp
```



```assembly
; 单目运算

inc D ; D = D + 1
dec D ; D = D - 1
neg D ; D = -D
not D ; D = ~D
```



```assembly
; 双目运算

add S, D  ; D = D + S
sub S, D  ; D = D - S
imul S, D ; D = D * S
xor S, D  ; D = D ^ S
or S, D   ; D = D | S
and S, D  ; D = D & S
```



```assembly
; 位移指令

sal I, D ; D = D << I 算术左移
shl I, D ; D = D << I 逻辑左移

sar I, D ; D = D >> I 算术右移
shr I, D ; D = D >> I 逻辑右移

算术左/右移：符号位保持不变，有符号数
逻辑左/右移：符号位参与位移，无符号数
```



```assembly
; 控制指令
cmp S1, S2  ; 比较指令，计算S1 - S2
test S2, S1 ; 按位与指令，计算S1 & S2
```



```assembly
; 置标志位
; CF：进位标志寄存器，它记录无符号操作的溢出，当溢出时会被设为1。
; ZF：零标志寄存器，当计算结果为0时将会被设为1。
; SF：符号标志寄存器，当计算结果为负数时会被设为1。
; OF：溢出标志寄存器，当计算结果导致了补码溢出时，会被设为1。
```



