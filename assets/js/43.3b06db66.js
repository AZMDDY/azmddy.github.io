(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{535:function(t,s,v){"use strict";v.r(s);var a=v(22),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"const-限定符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#const-限定符"}},[t._v("#")]),t._v(" const 限定符")]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("const")]),t._v("限定符，限定变量的值不能被改变，更准确的说是不能通过这个变量去改变这个变量的值，因为有指针和引用这两个东西。")])]),t._v(" "),v("h2",{attrs:{id:"const-define-enum"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#const-define-enum"}},[t._v("#")]),t._v(" const & define & enum")]),t._v(" "),v("p",[t._v("这三者都能够定义常量：")]),t._v(" "),v("ul",[v("li",[t._v("const:\n"),v("ul",[v("li",[t._v("有类型检查")]),t._v(" "),v("li",[t._v("不会改变变量的作用域")])])]),t._v(" "),v("li",[t._v("define:\n"),v("ul",[v("li",[t._v("没有类型安全检查")]),t._v(" "),v("li",[t._v("直接替换字符串")]),t._v(" "),v("li",[t._v("作用域从定义到"),v("em",[t._v("文件尾")]),t._v("，这里的"),v("em",[t._v("文件尾")]),t._v("是预编译处理时的文件展开的文件尾，除非使用**#undef**")])])]),t._v(" "),v("li",[t._v("enum:\n"),v("ul",[v("li",[t._v("有类型检查")]),t._v(" "),v("li",[t._v("只能是整型")]),t._v(" "),v("li",[t._v("定义一类相关的常量，enum 变量的值只能是这一类常量，安全性更高")])])])]),t._v(" "),v("h2",{attrs:{id:"const-指针"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#const-指针"}},[t._v("#")]),t._v(" const & 指针")]),t._v(" "),v("p",[t._v("有时候很容易搞混淆，指针常量，常量指针（指向常量的指针）傻傻分不清。关键点在于要搞清楚"),v("strong",[t._v("const")]),t._v("修饰的是谁。")]),t._v(" "),v("div",{staticClass:"language-cpp line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-cpp"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("p",[t._v("对于"),v("code",[t._v("const int* a = nullptr;")]),t._v("，首先看"),v("strong",[t._v("const")]),t._v("修饰的是"),v("code",[t._v("int* a")]),t._v(", 大家都知道"),v("code",[t._v("a")]),t._v("是指针，"),v("code",[t._v("*a")]),t._v("是"),v("code",[t._v("a")]),t._v("指针指向的值。那么"),v("code",[t._v("const int* a = nullptr;")]),t._v("就表示"),v("code",[t._v("a")]),t._v("指针指向的值不能通过"),v("code",[t._v("*a")]),t._v("去改变，不严谨的说，也就是"),v("code",[t._v("a")]),t._v("是指向常量的指针。"),v("code",[t._v("a")]),t._v("不一定要指向一个常量，编译器也不会去检查"),v("code",[t._v("a")]),t._v("是否真的指向的是一个常量，"),v("code",[t._v("a")]),t._v("也可以指向一个变量，只是不能通过"),v("code",[t._v("*a")]),t._v("去改变值而已。")]),t._v(" "),v("p",[t._v("对于"),v("code",[t._v("int* const a = nullptr;")]),t._v("，还是同样的思路，"),v("strong",[t._v("const")]),t._v("修饰的是"),v("code",[t._v("a")]),t._v("，也就是说"),v("code",[t._v("a")]),t._v("的值不能改变，即"),v("code",[t._v("a")]),t._v("是指针常量；")]),t._v(" "),v("p",[t._v("那对于 const 修饰的函数入参和返回值都是如此。")]),t._v(" "),v("h2",{attrs:{id:"const-引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#const-引用"}},[t._v("#")]),t._v(" const & 引用")]),t._v(" "),v("p",[t._v("这里要说的不是"),v("code",[t._v("const修饰引用表示不能通过这个引用去改变它的值")]),t._v("，而是可以用右值来初始化"),v("strong",[t._v("const 左值引用")]),t._v("，即"),v("code",[t._v("const int& a = 5")]),t._v("。"),v("code",[t._v("5")]),t._v("是一个"),v("code",[t._v("亡值")]),t._v("，不能取地址，也就无法引用它，但"),v("strong",[t._v("const")]),t._v("修饰后，可以在数据段开辟一个值为"),v("code",[t._v("5")]),t._v("的无名整型量，然后"),v("code",[t._v("a")]),t._v("与这个整型量进行绑定。")]),t._v(" "),v("h2",{attrs:{id:"const-类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#const-类"}},[t._v("#")]),t._v(" const & 类")]),t._v(" "),v("p",[t._v("类中定义的常量只能通过初始化列表的形式进行初始化或者"),v("code",[t._v("声明立即初始化")]),t._v("，当然，使用了"),v("code",[t._v("static")]),t._v("就可以在类外进行初始化了。")]),t._v(" "),v("h2",{attrs:{id:"const-函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#const-函数"}},[t._v("#")]),t._v(" const & 函数")]),t._v(" "),v("ol",[v("li",[t._v("const 不能修饰非成员函数。")]),t._v(" "),v("li",[t._v("const 修饰的成员函数不能访问非 const 成员。")]),t._v(" "),v("li",[t._v("const 是作为函数签名的一部分。")])]),t._v(" "),v("p",[v("code",[t._v("const")]),t._v("修饰的函数中不能访问非"),v("code",[t._v("const")]),t._v("变量。也就是说"),v("code",[t._v("void Func();")]),t._v("和"),v("code",[t._v("void Func() const;")]),t._v("是两个不同的函数。")])])}),[],!1,null,null,null);s.default=n.exports}}]);