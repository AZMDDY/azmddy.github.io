(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{374:function(t,s,v){"use strict";v.r(s);var a=v(4),_=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"const-限定符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const-限定符"}},[t._v("#")]),t._v(" const 限定符")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("const")]),t._v("限定符，限定变量的值不能被改变，更准确的说是不能通过这个变量去改变这个变量的值，因为有指针和引用这两个东西。")])]),t._v(" "),s("h2",{attrs:{id:"const-define-enum"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const-define-enum"}},[t._v("#")]),t._v(" const & define & enum")]),t._v(" "),s("p",[t._v("这三者都能够定义常量：")]),t._v(" "),s("ul",[s("li",[t._v("const:\n"),s("ul",[s("li",[t._v("有类型检查")]),t._v(" "),s("li",[t._v("不会改变变量的作用域")])])]),t._v(" "),s("li",[t._v("define:\n"),s("ul",[s("li",[t._v("没有类型安全检查")]),t._v(" "),s("li",[t._v("直接替换字符串")]),t._v(" "),s("li",[t._v("作用域从定义到"),s("em",[t._v("文件尾")]),t._v("，这里的"),s("em",[t._v("文件尾")]),t._v("是预编译处理时的文件展开的文件尾，除非使用**#undef**")])])]),t._v(" "),s("li",[t._v("enum:\n"),s("ul",[s("li",[t._v("有类型检查")]),t._v(" "),s("li",[t._v("只能是整型")]),t._v(" "),s("li",[t._v("定义一类相关的常量，enum 变量的值只能是这一类常量，安全性更高")])])])]),t._v(" "),s("h2",{attrs:{id:"const-指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const-指针"}},[t._v("#")]),t._v(" const & 指针")]),t._v(" "),s("p",[t._v("有时候很容易搞混淆，指针常量，常量指针（指向常量的指针）傻傻分不清。关键点在于要搞清楚"),s("strong",[t._v("const")]),t._v("修饰的是谁。")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("对于"),s("code",[t._v("const int* a = nullptr;")]),t._v("，首先看"),s("strong",[t._v("const")]),t._v("修饰的是"),s("code",[t._v("int* a")]),t._v(", 大家都知道"),s("code",[t._v("a")]),t._v("是指针，"),s("code",[t._v("*a")]),t._v("是"),s("code",[t._v("a")]),t._v("指针指向的值。那么"),s("code",[t._v("const int* a = nullptr;")]),t._v("就表示"),s("code",[t._v("a")]),t._v("指针指向的值不能通过"),s("code",[t._v("*a")]),t._v("去改变，不严谨的说，也就是"),s("code",[t._v("a")]),t._v("是指向常量的指针。"),s("code",[t._v("a")]),t._v("不一定要指向一个常量，编译器也不会去检查"),s("code",[t._v("a")]),t._v("是否真的指向的是一个常量，"),s("code",[t._v("a")]),t._v("也可以指向一个变量，只是不能通过"),s("code",[t._v("*a")]),t._v("去改变值而已。")]),t._v(" "),s("p",[t._v("对于"),s("code",[t._v("int* const a = nullptr;")]),t._v("，还是同样的思路，"),s("strong",[t._v("const")]),t._v("修饰的是"),s("code",[t._v("a")]),t._v("，也就是说"),s("code",[t._v("a")]),t._v("的值不能改变，即"),s("code",[t._v("a")]),t._v("是指针常量；")]),t._v(" "),s("p",[t._v("那对于 const 修饰的函数入参和返回值都是如此。")]),t._v(" "),s("h2",{attrs:{id:"const-引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const-引用"}},[t._v("#")]),t._v(" const & 引用")]),t._v(" "),s("p",[t._v("这里要说的不是"),s("code",[t._v("const修饰引用表示不能通过这个引用去改变它的值")]),t._v("，而是可以用右值来初始化"),s("strong",[t._v("const 左值引用")]),t._v("，即"),s("code",[t._v("const int& a = 5")]),t._v("。"),s("code",[t._v("5")]),t._v("是一个"),s("code",[t._v("亡值")]),t._v("，不能取地址，也就无法引用它，但"),s("strong",[t._v("const")]),t._v("修饰后，可以在数据段开辟一个值为"),s("code",[t._v("5")]),t._v("的无名整型量，然后"),s("code",[t._v("a")]),t._v("与这个整型量进行绑定。")]),t._v(" "),s("h2",{attrs:{id:"const-类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const-类"}},[t._v("#")]),t._v(" const & 类")]),t._v(" "),s("p",[t._v("类中定义的常量只能通过初始化列表的形式进行初始化或者"),s("code",[t._v("声明立即初始化")]),t._v("，当然，使用了"),s("code",[t._v("static")]),t._v("就可以在类外进行初始化了。")]),t._v(" "),s("h2",{attrs:{id:"const-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const-函数"}},[t._v("#")]),t._v(" const & 函数")]),t._v(" "),s("ol",[s("li",[t._v("const 不能修饰非成员函数。")]),t._v(" "),s("li",[t._v("const 修饰的成员函数不能访问非 const 成员。")]),t._v(" "),s("li",[t._v("const 是作为函数签名的一部分。")])]),t._v(" "),s("p",[s("code",[t._v("const")]),t._v("修饰的函数中不能访问非"),s("code",[t._v("const")]),t._v("变量。也就是说"),s("code",[t._v("void Func();")]),t._v("和"),s("code",[t._v("void Func() const;")]),t._v("是两个不同的函数。")])])}),[],!1,null,null,null);s.default=_.exports}}]);